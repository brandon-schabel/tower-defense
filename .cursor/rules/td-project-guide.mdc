---
description: Project Architecture Guiide
globs: 
alwaysApply: true
---
Great! I will create a comprehensive Cursor rules file for your open-source Phaser-based tower defense game. It will cover:

- **Project Architecture**: Explanation of folder structure, file naming, and modular design.
- **Phaser & TypeScript Best Practices**: Recommendations for structuring Phaser projects efficiently.
- **Development Conventions**: Guidelines on naming conventions, structuring components, and state management.
- **Open-Source Contribution Guidelines**: Ensuring maintainability and clarity for contributors.
- **Game-Specific Principles**: How the game is structured, core mechanics, and extensibility.

I will structure it in a clear and organized manner as a plain text document. I'll let you know when it's ready!

# Project Architecture

- **Folder Structure**: The project is organized into distinct folders for clarity and modularity. For example, a common structure is:  
  - `src/` – Contains all game source code (TypeScript files) ([GitHub - phaserjs/template-vite-ts: A Phaser 3 project template that uses TypeScript and Vite for bundling](mdc:https:/github.com/phaserjs/template-vite-ts#:~:text=%2A%20%60index.html%60%20,to%20help%20with%20page%20layout)).  
    - `scenes/` – Each game state is a separate Phaser Scene class file (e.g. `boot-scene.ts`, `game-scene.ts`) ([GitHub - phaserjs/template-vite-ts: A Phaser 3 project template that uses TypeScript and Vite for bundling](mdc:https:/github.com/phaserjs/template-vite-ts#:~:text=%2A%20%60src%2Fvite,assets%20used%20by%20the%20game)). Keeping one class per file (extending `Phaser.Scene`) helps maintain organization ([What are Phaser 3 bad/best practices? - Phaser 3 - Phaser](mdc:https:/phaser.discourse.group/t/what-are-phaser-3-bad-best-practices/5088#:~:text=Extend%20)).  
    - `entities/` (or `objects/`) – Game entity classes such as towers, enemies, bullets. Each class (e.g. `Tower.ts`, `Enemy.ts`) resides in its own file for modular design.  
    - `managers/` – Manager/controller classes that handle game systems and logic (e.g. `wave-manager.ts` for enemy waves, `tower-manager.ts` for tower targeting logic). This separates high-level game logic from individual entities.  
    - `ui/` – User Interface classes and scenes. UI elements (HUD, menus, etc.) are organized here, possibly including a dedicated `UIScene` for overlays.  
    - `config/` – Configuration constants and data. For instance, a `constants.ts` could store asset keys, scene keys, balance values, etc., to avoid hard-coding strings throughout the code ([What are Phaser 3 bad/best practices? - Phaser 3 - Phaser](mdc:https:/phaser.discourse.group/t/what-are-phaser-3-bad-best-practices/5088#:~:text=Use%20a%20file%20for%20constants)).  
    - `main.ts` (or `index.ts`) – The entry point that initializes the Phaser game, configures game settings (canvas size, physics, etc.), and starts the first scene ([GitHub - phaserjs/template-vite-ts: A Phaser 3 project template that uses TypeScript and Vite for bundling](mdc:https:/github.com/phaserjs/template-vite-ts#:~:text=%2A%20%60index.html%60%20,to%20help%20with%20page%20layout)).  
  - `assets/` – Game assets such as images, spritesheets, audio, and level data. These might be organized into subfolders like `assets/images/`, `assets/audio/`, `assets/data/` for JSON wave definitions or tilemaps. (In some setups, a `public/assets` folder is used for static asset files ([GitHub - phaserjs/template-vite-ts: A Phaser 3 project template that uses TypeScript and Vite for bundling](mdc:https:/github.com/phaserjs/template-vite-ts#:~:text=%2A%20%60src%2Fscenes%2F%60%20,assets%20used%20by%20the%20game)).)  
  - `dist/` – The distribution folder where the build outputs (bundled JS, asset files) go for release. This is generated by the build process (e.g. Webpack or Vite) and is what gets shipped (for example, packaged for Steam).  

- **File Organization & Modular Design**: Each module has a clear purpose. Scenes handle lifecycle and orchestration, entity classes handle behavior of specific game objects, and manager classes coordinate groups of objects or game-wide systems. This separation of concerns makes the codebase easier to navigate and extend. For example, the `WaveManager` can read wave configurations and spawn enemies accordingly, without cluttering the main game scene code. Likewise, a `TowerManager` could update all towers each frame (checking for targets, firing) so that the Scene’s `update` remains clean. Overall, this modular architecture ensures that changes in one system (e.g. tweaking tower behavior) have minimal impact on others, improving maintainability.

# Phaser & TypeScript Best Practices

- **Use TypeScript for Robustness**: Leverage TypeScript to catch errors early and keep code organized. TypeScript’s type system helps manage complex game data and interactions, making development more predictable and safer ([What are Phaser 3 bad/best practices? - Phaser 3 - Phaser](mdc:https:/phaser.discourse.group/t/what-are-phaser-3-bad-best-practices/5088#:~:text=I%20guess%20there%20is%20no,Phaser%20games%20in%20multiple%20ways)). Define interfaces or types for things like enemy stats or tower configurations to ensure consistency. For example, you might define an `EnemyConfig` interface to type-check properties such as health, speed, and path for enemies.

- **Phaser Scene Management**: Structure the game with multiple `Phaser.Scene` classes, each in its own file ([What are Phaser 3 bad/best practices? - Phaser 3 - Phaser](mdc:https:/phaser.discourse.group/t/what-are-phaser-3-bad-best-practices/5088#:~:text=Extend%20)). Common scenes include Boot (for initial loading), Preloader (loading assets), Main Menu, Game (main gameplay), perhaps a Pause or Game Over scene, and a UI scene. Use Phaser’s scene transitions (e.g. `this.scene.start('GameScene')`) to move between states. Keep scene keys in a constants file to avoid typos when referencing them ([What are Phaser 3 bad/best practices? - Phaser 3 - Phaser](mdc:https:/phaser.discourse.group/t/what-are-phaser-3-bad-best-practices/5088#:~:text=Use%20a%20file%20for%20constants)).

- **Efficient Game Loop**: Aim to keep the `update()` methods of scenes and game objects as light as possible. Heavy or complex logic can be moved into helper classes or managers that are called from `update` rather than inline. In larger games, one approach is to use an event-driven or component-based design so that the Scene’s update simply emits an update event or calls update on manager objects ([What are Phaser 3 bad/best practices? - Phaser 3 - Phaser](mdc:https:/phaser.discourse.group/t/what-are-phaser-3-bad-best-practices/5088#:~:text=Keep%20the%20Scene%E2%80%99s%20update%20method,as%20empty%20as%20possible)). This prevents the main game loop from becoming monolithic and hard to maintain.

- **Phaser Features & Optimization**: Make full use of Phaser’s features for better performance and cleaner code:
  - Use Phaser Groups or Containers to manage collections of similar objects. For instance, maintain an enemy group, a tower group, and a bullet group. This allows bulk operations like iterating all enemies or doing group collision checks easily ([Tower Defense Tutorial](mdc:https:/phaser.io/news/2018/12/tower-defense-tutorial#:~:text=,managing%20enemies%2C%20turrets%20and%20bullets)). Phaser 3 groups are flexible for organizing and updating multiple objects of the same type.
  - Utilize Arcade Physics (or an appropriate physics system) for collision detection and movement, as it’s well-optimized. In a tower defense, Arcade Physics can handle checking if bullets overlap enemies, saving you from writing custom collision logic ([Tower Defense Tutorial](mdc:https:/phaser.io/news/2018/12/tower-defense-tutorial#:~:text=game%20development%20process,fully%20functional%20tower%20defense%20game)). Configure physics world bounds and object bodies appropriately so that off-screen objects (like bullets that miss) can be destroyed or recycled.
  - Consider object pooling for frequently created/destroyed objects like bullets or enemies. Reusing objects can reduce garbage collection overhead mid-game. Phaser’s `Group` with the `remove` and `add` methods, or disabling objects instead of destroying them, can act as a simple pooling mechanism.
  - Use the Phaser Loader efficiently: preload all necessary assets in a preload scene so gameplay isn’t interrupted by loads. Organize assets with clear keys (defined in constants) and file paths. This makes it easy to swap assets or manage loading order centrally.

- **Scene Communication**: Avoid tight coupling between scenes. When scenes need to share data (for example, the Game scene updating the UI scene with the current score or lives), use the event emitter or Phaser’s data systems instead of direct references ([
		
			How to Communicate Between Scenes in Phaser 3 @ Playful Game Developmet Blog by Ourcade
		
	](https://blog.ourcade.co/posts/2020/phaser3-how-to-communicate-between-scenes/#:~:text=One%20common%20best%20practice%20is,code%20in%20a%20separate%20Scene)). A common pattern is creating a global `EventEmitter` (or using `this.events` on scenes) to dispatch events like `"PLAYER_HIT"` or `"WAVE_COMPLETE"`. The UI scene can listen for these events and update the display accordingly. This decoupled approach improves modularity and testing, since scenes don’t directly depend on each other’s internals.

- **TypeScript Integration with Phaser**: Use the Phaser type definitions to your advantage. Import Phaser types (e.g. `Phaser.Types.Input.Keyboard`, `Phaser.GameObjects.Image`) as needed to get IntelliSense and compile-time checking. Enable strict null checking and other compiler options in `tsconfig.json` to catch mistakes early. Additionally, prefer explicit casts or Phaser-provided methods when dealing with dynamic data (for instance, when retrieving data from Phaser’s registry or an any-type JSON, cast to the expected interface). This ensures the code remains type-safe throughout.

# Development Conventions

- **Naming Conventions**: Consistent naming makes the project accessible to all contributors. Use **kebab-case (dashed-case)** for file and folder names ([Typescript Filename Convention | Restackio](mdc:https:/www.restack.io/p/typescript-knowledge-filename-convention#:~:text=,Below%20is%20an%20example%20configuration)). For example, files are named `game-scene.ts`, `tower-manager.ts`, etc., all in lowercase with words separated by hyphens. Class names and TypeScript types should use **PascalCase** (e.g. class `EnemyManager` in file `enemy-manager.ts`), and variables and functions use **camelCase** (e.g. `spawnRate`, `updateScore()`), following typical TypeScript style. Constants (like configuration values) can be in UPPER_SNAKE_CASE or PascalCase if they are enum-like. The key is consistency – the codebase should look uniform no matter who contributes to it.

- **Code Structure and Style**: Organize code for readability. Each file should ideally contain a single class or module. Within a class, order members by relevance (for example, public methods grouped together, private helper methods at the bottom, etc.). Avoid extremely long functions – if a function exceeds, say, 50 lines, consider refactoring into smaller helper functions. Use comments and JSDoc to explain non-obvious code logic or algorithmic decisions so future maintainers understand the intent. For example, if implementing an enemy pathfinding algorithm or a targeting strategy, include a brief comment on how it works. Use blank lines to separate logical sections of code within functions to improve readability.

- **Scene and State Management**: Treat Phaser Scenes as the main state machine for the game flow. Common practice is to suffix scene classes with `Scene` (e.g. `GameScene`, `MainMenuScene`) and use their keys defined in a constants file for transitions. The game might start with `BootScene` -> `PreloadScene` -> `MainMenuScene` -> `GameScene`, etc. Manage global game state (like player lives, score, current wave number) in a controlled way. You can use Phaser’s **Data Manager** or **registry** (accessible via `this.registry`) to store persistent data that needs to survive across scene switches. This is better than using global variables, as the registry is built into Phaser and can emit events on data change if needed. For example, updating `this.registry.values.lives` could trigger the UI scene to update the lives display. Another option is maintaining a separate singleton state object or service that scenes can import, but be cautious to keep it simple and well-documented if you do.

- **File and Folder Conventions**: Place files in their appropriate folder based on feature/type. Resist the temptation to put all logic in one scene or one file. For instance, code related to enemy behavior belongs in the enemy class or enemy manager, not spread across the tower or wave classes. Similarly, UI-related code (buttons, HUD updates) should reside in UI classes or the UI scene. Keeping a clean separation (as outlined in the architecture) makes it easier to locate code. If new features are added, create new files/folders as necessary rather than bloating existing ones. For example, if a new type of tower or enemy is introduced, add a new class for it even if it shares some logic with existing ones (you might then refactor common logic into a parent class or utility).

- **Coding Standards**: Follow standard coding guidelines. Use a linter (ESLint with a TypeScript plugin, or TSLint) to enforce style and catch potential errors. We enforce naming conventions via lint rules (for example, ensuring kebab-case file names) ([Typescript Filename Convention | Restackio](mdc:https:/www.restack.io/p/typescript-knowledge-filename-convention#:~:text=,Below%20is%20an%20example%20configuration)), as well as standard formatting (semi-colons, quotes, spacing). The project should include an ESLint configuration or Prettier settings that all contributors adhere to. Before committing code, run the linter and fix any warnings to maintain consistency. Additionally, try to keep the codebase ES6+ compliant (using `const/let`, arrow functions, etc., which Babel/TypeScript will transpile as needed) and avoid deprecated Phaser features or old coding patterns.

# Open-Source Contribution Guidelines

- **Project Maintainability**: We welcome contributions that improve the game or fix issues, but maintaining code quality is paramount. All code contributions should strive to be clean, well-documented, and tested. If you fix a bug or add a feature, try to test it in-game (e.g., if you implement a new tower type, play a few waves to ensure it works without errors). Avoid duplicating code – if two towers share logic, consider abstracting it in a base class or utility function. When in doubt, open an issue or discussion to propose big changes before implementing, so the maintainers and community can offer feedback and ensure the approach aligns with the project’s vision.

- **Coding Standards and Style**: Adhere to the established coding style of the project. This includes the naming and structural conventions described above. Inconsistent code (in naming, formatting, or approach) may be refactored by maintainers to keep the codebase coherent. It’s recommended to configure your editor with the project’s linting/formatting rules (e.g. editorconfig, ESLint, Prettier) so that you automatically follow the style. Comments and documentation are appreciated, especially for complex sections. If you contribute new functionality, consider adding or updating comments and JSDoc for those parts of the code.

- **Version Control and Process**: The project uses Git for version control. Typically, you should fork the repository and work on a feature branch (e.g. `feature/add-new-tower`) then submit a Pull Request. Ensure your branch is up-to-date with the latest `main` (or `dev` branch if one is designated) before submitting. Write clear commit messages that explain the *why* of changes, not just the *what*. For example, "Improve tower targeting logic to prioritize first enemy" is more informative than "Update Tower class". If your contribution addresses an open issue, you can reference it in the PR description (e.g., "Closes #12 - fixes enemy pathfinding glitch").

- **Contribution Guidelines & Code of Conduct**: For larger contributions, please check if the project has a `CONTRIBUTING.md` file and read it. We follow standard open-source practices, meaning we have guidelines for how to contribute and a code of conduct to foster a welcoming environment ([Open Source 标签文章列表 - RssTabs.com](mdc:https:/www.rsstabs.com/zh/posts?tag=Open%20Source#:~:text=Open%20Source%20%E6%A0%87%E7%AD%BE%E6%96%87%E7%AB%A0%E5%88%97%E8%A1%A8%20,with%20your%20contribution%20guidelines)). By contributing, you agree to abide by these rules. Essentially: be respectful in communications (no harassment or rude behavior), discuss ideas constructively, and be open to feedback on your code. Maintain a friendly tone in code reviews and discussions. If you’re a newcomer to open source, feel free to ask for help; we aim to make the project a learning opportunity as well as a collaborative effort.

- **Documentation and Comments**: If your contribution changes how a feature works or adds a new feature, update the relevant documentation. This could mean editing this rules file or other markdown docs, or simply ensuring code comments are up to date. For example, if you adjust the wave spawning algorithm, also update any comments or docs that describe wave behavior. This ensures future maintainers or contributors can understand the current intended behavior easily. Remember, an open-source project’s value is not just in the code, but also in how easy it is for others to pick it up and continue development.

# Game-Specific Principles

**Game Mechanics Overview**: This tower defense game follows classic mechanics: waves of enemies traverse a path from a spawn point to a destination (usually the player’s base). The player builds towers to attack and destroy these enemies before they reach the end. If too many enemies get through, the player loses (e.g., loses health or lives). The player typically earns currency by defeating enemies, which can be spent to build new towers or upgrade existing ones between waves. Each level may consist of multiple waves of increasing difficulty. Under the hood, enemies move along predefined paths on the map ([Tower Defense Tutorial](mdc:https:/phaser.io/news/2018/12/tower-defense-tutorial#:~:text=,managing%20enemies%2C%20turrets%20and%20bullets)), often following waypoints or a spline curve defined in the level data. Using Phaser’s path or timeline features can simplify moving enemies along a set route. Towers fire projectiles (or apply effects) to damage enemies. The game ends in victory if all waves are cleared, or defeat if the base life reaches zero.

**Enemy Targeting**: Towers automatically target enemies within their range. The targeting logic is crucial for gameplay balance and is typically handled in the tower (or TowerManager) update loop. A common strategy is to target the *first* enemy that entered the tower’s range (usually meaning the enemy closest to the exit, so that towers prioritize those furthest along the path). Another approach is targeting the *closest* enemy to the tower, or the *strongest/weakest* in range, but by default we keep it simple: for example, **First-In-Range** targeting. Implementation-wise, each tower can check the list of active enemies (e.g., an enemy group) and filter those within its radius. Then it picks one according to the strategy (first along path could be determined by who has progressed the furthest in the path or simply the one with the highest path index). Once a target is acquired, the tower can continue to attack that target until it leaves range or is destroyed, then acquire a new target. This prevents towers from switching targets too frequently. The targeting function should be efficient – e.g., using distance squared comparisons to avoid expensive sqrt operations, or using spatial partitioning if there are many enemies. Since Phaser provides groups, one can iterate through an enemy group to find a valid target. The tower then might create a bullet aimed at that enemy. If no enemies are in range, the tower does nothing until one enters its range.

**Tower Placement**: Towers are placed by the player on the game map. The rules for placement depend on game design:
- If the game uses **fixed build spots**, the map will have designated locations where towers can be built (e.g., nodes or empty sockets on the map). In this case, the game might highlight available spots, and the player clicks to build a tower on one. The code should ensure a tower is only built on an empty spot and deduct the appropriate cost.
- If the game allows **free placement** on open terrain, then we must ensure towers cannot be placed on the enemy path or on top of each other. Typically, the map might be divided into a grid, and towers snap to grid positions for neat placement. The placement logic should check that the chosen tile is buildable (not an obstacle or path). Phaser’s input events can be used to drag and place towers, with a preview sprite showing valid/invalid placement (e.g., turn red if the location is invalid). Once placed, a tower becomes a part of the tower group and is now active.
- Towers should probably not block the path entirely (unless the game intentionally allows mazing, where players create the maze). In our design, assume either fixed spots or that the path is off-limits to building. This can be enforced by tagging path tiles as unbuildable in a grid, or by distance checks.
- Each tower has certain attributes like cost, range, damage, and fire rate. These could be defined in a tower config object. When placing a tower, subtract the cost from the player's available resources and instantiate the appropriate tower class at that location. It’s good practice to centralize tower definitions so that balancing changes (damage, range, etc.) can be done in one place.

**Wave Management**: Enemy waves are controlled by a **WaveManager** (or similar system). Wave data can be defined in a JSON or JS object – for example, an array of wave definitions, where each wave lists the types and quantities of enemies, and perhaps the spawn interval or timing. The WaveManager is responsible for starting each wave and spawning enemies according to the schedule. A simple approach is: when a wave starts, set a timer to spawn an enemy every X seconds until all enemies for that wave are spawned. Each enemy would be added to the enemy group and assigned to follow the path towards the base. The WaveManager should also track when a wave is finished (e.g., all enemies spawned and either destroyed or reached the end) and then possibly trigger a short delay before the next wave or wait for player input (like a “Next Wave” button). It may dispatch an event like `"WAVE_COMPLETE"` when all enemies of a wave are dealt with, which the UI or Game scene can listen for to then initiate the next wave or show a inter-wave summary. Managing the timing is important – use Phaser’s Timer events or scene `time.delayedCall` for precise spawn timing. Additionally, the WaveManager could increase difficulty each wave (for instance, increment enemy health or spawn rate) if not predefined, to scale challenge. Ensure that wave logic is independent of frame rate (using time-based spawning, not just `update` counts, so the game spawns consistently even if frames fluctuate).

**UI Structure**: The user interface is separated to keep it modular and not interfere with core gameplay logic. Often, the UI is implemented in a **UIScene** running in parallel with the Game scene ([
		
			How to Communicate Between Scenes in Phaser 3 @ Playful Game Developmet Blog by Ourcade
		
	](https://blog.ourcade.co/posts/2020/phaser3-how-to-communicate-between-scenes/#:~:text=One%20common%20best%20practice%20is,code%20in%20a%20separate%20Scene)). This scene can contain all HUD elements like the score, remaining lives, current wave number, money, etc., as well as buttons (e.g., to pause, to start next wave, or to upgrade/sell towers). Separating UI into its own scene means it can have a UI-specific camera (usually static, not moving with the game world) and it won’t be affected by any transformations in the main game scene. Communication between the game scene and UI scene can be done via events – for example, when the player’s lives change or money updates, the game scene emits an event that the UI scene listens to and updates the text fields accordingly. This decoupling follows Phaser best practices for clean code architecture ([
		
			How to Communicate Between Scenes in Phaser 3 @ Playful Game Developmet Blog by Ourcade
		
	](https://blog.ourcade.co/posts/2020/phaser3-how-to-communicate-between-scenes/#:~:text=One%20common%20best%20practice%20is,code%20in%20a%20separate%20Scene)). 

The UI elements should be well-organized, typically anchored to the screen edges or corners. For instance, lives and score might be top-left, money and wave info top-right, and a control panel or tower selection menu at the bottom. Use consistent styling for fonts and colors to make the UI clear. In code, you might have a UI manager or just handle it within the UIScene’s update and event callbacks. Each UI component (like a Text or Image for an icon) can be created in the UIScene’s `create()` method and stored as a class member for updates. If the UI needs to interact with the game (for example, a "Start Wave" button), it can emit an event that the Game scene listens to (or directly call a method on Game scene via `this.scene.get('GameScene')` if absolutely necessary). However, prefer events to keep scenes independent.

Finally, ensure the UI does not get overcrowded. Only display relevant information and use intuitive icons or labels (heart for lives, coin for money, etc.). A clean UI contributes to a better player experience and a maintainable codebase, as future contributors can easily adjust UI layout or add new indicators without touching core game logic.

