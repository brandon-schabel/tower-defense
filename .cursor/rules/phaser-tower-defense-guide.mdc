---
description: Phaser tower defense dev guide
globs: *.ts
alwaysApply: false
---
Key Points
Phaser is a JavaScript library for HTML5 games, ideal for building a tower defense game with features like UI, entities, and enemy AI.
Use Phaser's Scene API for managing game states like the main menu and gameplay, and Vite for fast project setup.
Implement player movement with WASD, tower placement via a build toolbar, and enemy targeting logic using Phaser's input and physics systems.
Manage rounds with build and combat phases, ensuring enemies spawn and attack based on proximity to the user, towers, or base.
A surprising detail is that enemies dynamically recalculate their path every second, adapting to destroyed targets, enhancing gameplay strategy.
Project Setup with Phaser and Vite
To start, set up your project using Vite, a modern web bundler, and integrate Phaser for game development. Follow the official Phaser + Vite Template for a quick setup, ensuring Node.js is installed. This template supports hot-reloading and fast builds, streamlining development. For detailed steps, refer to saricden's guide.
Creating and Managing Scenes
Phaser uses scenes to organize game parts. Create a MenuScene for the main menu with buttons to start a new game, and a GameScene for gameplay. Use this.scene.start('GameScene') to switch scenes, leveraging Phaser's Scene Manager for smooth transitions. This approach ensures a modular game structure, as detailed in Phaser's Scenes documentation.
Implementing Game Entities and UI
In GameScene, set up the game world with a camera following the player. Implement the player using WASD for movement and spacebar for shooting, with a range of about 200 pixels. Create a build toolbar at the screen's bottom using a container, adding interactive buttons for tower types (normal, sniper, area) with prices. Enter build mode by selecting a tower, showing a transparent placeholder following the mouse, and place it on click if affordable and within bounds.
Managing Rounds and Enemy AI
Manage game states with build and combat phases. In build phase, players can place towers; clicking "start round" switches to combat, spawning enemies. Enemies prioritize targeting the player if within range, then towers, and finally the base, recalculating paths every second if targets are destroyed. This dynamic AI enhances strategic depth, as enemies adapt to game changes, detailed in Phaser's input and physics guide.
Handling Game Over and Progression
Track player and base health; game over occurs if either reaches zero. Between rounds, heal the player by 20 health points, allowing strategic planning. Use timers for enemy spawns, ensuring rounds progress with increasing difficulty, as outlined in Phaser's time events documentation.
Survey Note: Comprehensive Technical Guide for Building a Tower Defense Game with Phaser
This survey note provides an in-depth exploration of using Phaser, a robust JavaScript library for HTML5 game development, to build a tower defense game. It covers setup, scene management, entity implementation, UI design, and game mechanics, ensuring a thorough understanding for developers. The guide is based on the provided game plan, focusing on Phaser APIs useful for tower defense game development.
Introduction to Phaser and Project Setup
Phaser is an open-source framework for creating browser-based games, supporting Canvas and WebGL rendering. It is particularly suited for tower defense games due to its robust scene management, input handling, and physics systems. To begin, set up the project using Vite, a modern bundler known for its speed and developer experience. The official Phaser + Vite Template, updated to work with Phaser 3.70.0 and Vite 5.0.8, simplifies this process, offering hot-reloading and optimized builds. Installation involves ensuring Node.js is installed and running npm create vite@latest with the Vanilla JavaScript template, then installing Phaser via npm. For detailed setup, refer to saricden's guide.
The project structure includes index.html for the game canvas, main.js for game initialization, and separate files for scenes. This modular approach facilitates maintenance and scalability, aligning with modern web development practices.
Scene Management: MenuScene and GameScene
Phaser's scene system is central to game organization, allowing developers to create self-contained game worlds. Each scene manages its own game objects, input, and physics, making it ideal for separating the main menu from gameplay.
MenuScene Implementation: Create a MenuScene by extending Phaser.Scene, defining it with a unique key (MenuScene). In the create method, add UI elements like a "Start Game" button using this.add.text, setting it interactive with setInteractive() and handling clicks with on('pointerdown') to start GameScene via this.scene.start('GameScene'). This ensures a seamless transition, as described in Phaser's Scenes documentation.
GameScene Overview: The GameScene handles the core gameplay, including build and combat phases. Initialize it similarly, setting up the camera with this.cameras.main.setZoom(1) and this.cameras.main.startFollow(user) to track the player, ensuring a dynamic view. Scene switching is managed through the Scene Manager, supporting data passing for state persistence, detailed in Switch Between Scenes in Phaser 3.
Implementing Game Entities: Player, Base, and Towers
Game entities include the player, base, and towers, each with specific behaviors implemented using Phaser's game object system.
Player Implementation: The player, controlled with WASD for movement and spacebar for shooting, is a Phaser.GameObjects.Sprite. Create a User class extending Sprite, initializing with position and adding to the scene with scene.add.existing(this). Use this.input.keyboard.addKeys('W,S,A,D,SPACE') for input, updating velocity in the update method based on key states. Shooting involves finding the nearest enemy within range (200 pixels) and creating a projectile with this.scene.add.image, setting velocity with this.scene.physics.velocityFromRotation. Health management includes healing 20 points per round, with game over if health reaches zero, as outlined in Phaser's input and physics guide.
Base Implementation: The base, the final target for enemies, is another Sprite with health. Create a Base class, initializing with position and health (100), adding to the scene. Implement receiveDamage to reduce health, triggering game over (this.scene.gameOver()) if health <= 0, ensuring strategic gameplay focus.
Tower Implementation: Towers (normal, sniper, area) are implemented as custom Sprite classes, each with unique attack behaviors. Create a base Tower class with properties like range (100 pixels), attack speed, and damage, updating in the update method to find targets and shoot projectiles. Subclass for specific types:
Normal and sniper towers target specific enemies, using Phaser.Math.Distance.Between to find the nearest within range.
Area towers shoot multiple projectiles outward, using a loop to create projectiles at different angles (e.g., 60 degrees apart) with Phaser.Math.DegToRad. Load tower icons as SVG assets in preload with this.load.image('tower1Icon', 'path/to/tower1.svg'), supporting the game's visual design, as detailed in Phaser's asset loading documentation.
UI Design: Build Toolbar and Build Mode
The build toolbar, always at the screen's bottom, facilitates tower placement. Create a container with this.add.container(0, this.sys.game.config.height - 100, []), adding interactive buttons for each tower type using this.add.image with setInteractive() and on('pointerdown') to select towers. Display prices and disable buttons if the player lacks funds, managed by a playerMoney variable.
In build mode, triggered by tower selection, show a transparent placeholder (setAlpha(0.5)) following the mouse with this.input.on('pointermove'). On click (pointerdown), validate position within bounds and affordability, creating the tower with createTower and deducting cost, then exiting build mode. This ensures intuitive placement, leveraging Phaser's input system, as described in Phaser's input events documentation.
Managing Rounds and Enemy AI
Rounds alternate between build and combat phases, managed by a state variable (gameState: 'build', 'combat', 'roundEnd'). Define rounds with enemy spawn patterns (e.g., time delays and types) in an array, using timers with this.time.addEvent for spawning. In combat, enemies move towards targets, prioritizing the player if within range, then towers, then the base, using Phaser.Math.Distance.Between for range checks.
Enemy AI: Implement an Enemy class extending Sprite, initializing with position and target. Use a timer (this.scene.time.addEvent) to check targets every second, recalculating if destroyed with findNewTarget, enhancing adaptability. Movement uses this.scene.physics.velocityFromRotation towards the target, attacking within range by reducing target health, detailed in Phaser's physics documentation.
Round Progression: Start rounds by hiding the build toolbar and spawning enemies, tracking active enemies with this.enemies.countActive(). On round end (no enemies), show the "next round" button, healing the player by 20 health in startNextRound, ensuring strategic depth, as outlined in Phaser's time events documentation.
Handling Game Over and Additional Features
Game over occurs if player or base health reaches zero, implemented by calling gameOver in respective classes, potentially switching to a GameOverScene with a message. Additional features include pausing/play with keyboard input, a menu button for save/exit (using this.scene.pause and this.scene.resume), and settings, leveraging Phaser's event system for UI interactions, as detailed in Phaser's scene systems documentation.
Conclusion and Next Steps
This guide covers essential Phaser APIs for building a tower defense game, from setup to gameplay mechanics. Developers can extend functionality by adding save systems, more complex enemy AI, or multiplayer features, leveraging Phaser's extensible architecture. For further learning, explore Phaser's official examples for additional inspiration.
Key Citations
saricden's guide on setting up Phaser with Vite
