---
description: Tower Defense Testin Strategy
globs: *.test.ts
alwaysApply: false
---
Key Points
Test Phaser tower defense games with Bun's test framework for unit tests and Puppeteer for functional tests, ensuring fast and reliable testing.
Use Bun's Jest-like syntax for unit tests, focusing on game logic like resource management and enemy targeting.
For functional tests, run Puppeteer scripts with Bun to simulate user interactions, such as starting games or placing towers.
Manual testing is essential for gameplay experience, especially with dynamic enemy path recalculation every second, enhancing strategy.
Setting Up Bun's Test Framework
To start testing your Phaser tower defense game with Bun, ensure Bun is installed by following the instructions at Bun Docs. Update your package.json to use "test": "bun test" for running tests. Create test files with extensions like *.test.ts for TypeScript support, which Bun handles natively.
Writing Unit Tests
Bun's test framework uses a Jest-like API, importing expect and test from "bun:test". For example, test the GameState class's resource management:
ts
// game-state.test.ts
import { expect, test } from "bun:test";
import GameState from '../utils/game-state';

test('spendResources deducts resources if sufficient', () => {
  const gameState = new GameState();
  gameState.earnResources(100);
  const result = gameState.spendResources(50);
  expect(result).toBe(true);
  expect(gameState.getResources()).toBe(50);
});

test('spendResources fails if insufficient', () => {
  const gameState = new GameState();
  gameState.earnResources(100);
  const result = gameState.spendResources(150);
  expect(result).toBe(false);
  expect(gameState.getResources()).toBe(100);
});
Run tests with bun test, which searches for files like *.test.ts recursively.
Making Game Logic Testable
To test game logic, extract pure functions. For instance, create a findNearest utility to find the closest enemy, testable without Phaser:
ts
// utils.ts
export function findNearest(position: { x: number; y: number }, points: { x: number; y: number }[]): { x: number; y: number } | null {
  if (points.length === 0) return null;
  let nearest = points[0];
  let minDistance = distance(position, nearest);
  for (let i = 1; i < points.length; i++) {
    const dist = distance(position, points[i]);
    if (dist < minDistance) {
      minDistance = dist;
      nearest = points[i];
    }
  }
  return nearest;
}

function distance(p1: { x: number; y: number }, p2: { x: number; y: number }) {
  return Math.hypot(p2.x - p1.x, p2.y - p1.y);
}
Test it with Bun:
ts
// utils.test.ts
import { expect, test } from "bun:test";
import { findNearest } from '../utils';

test('findNearest returns the closest point', () => {
  const position = { x: 0, y: 0 };
  const points = [
    { x: 1, y: 1 },
    { x: 2, y: 2 },
    { x: 0.5, y: 0.5 }
  ];
  const nearest = findNearest(position, points);
  expect(nearest).toStrictEqual({ x: 0.5, y: 0.5 });
});
This approach ensures testability by isolating logic from Phaser's browser dependencies.
Functional Testing with Puppeteer and Bun
For tests requiring browser interaction, use Puppeteer. Install it with Bun:
sh
bun add -D puppeteer
Write a test to start the game and verify the canvas:
ts
// functional.test.ts
import puppeteer from 'puppeteer';

test('Start New Game', async () => {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  await page.goto('http://localhost:3000');
  await page.click('#start-new-game');
  await page.waitForSelector('#game-container canvas');
  const canvas = await page.$('#game-container canvas');
  expect(canvas).not.toBeNull();
  await browser.close();
}, 10000); // Increase timeout for browser operations
Run with bun test functional.test.ts, ensuring your Vite server is running locally.
Manual Testing
Play the game manually to verify gameplay, focusing on:
Main menu navigation and game start.
Build mode for tower placement, ensuring dynamic enemy path recalculation every second for strategic depth.
Combat phases, checking enemy targeting (user, then towers, then base).
Performance with many entities, using browser dev tools to monitor FPS.
Comprehensive Technical Guide for Testing Tower Defense Games with Bun's Test Framework
This guide provides an in-depth exploration of testing strategies for a Phaser-based tower defense game using Bun's test framework, focusing on unit tests, functional tests with Puppeteer, and manual testing. It ensures a thorough understanding for developers, leveraging Bun's speed and compatibility with existing JavaScript tools.
Introduction to Testing with Bun
Phaser is an open-source framework for creating browser-based games, ideal for tower defense games due to its scene management, input handling, and physics systems. Testing such games requires addressing both pure logic and browser-dependent rendering. Bun, a fast JavaScript runtime by Jarred Sumner, offers a built-in test runner with Jest-like syntax, running 100x faster than Jest, making it suitable for unit tests. For functional tests, Puppeteer can be integrated, running within Bun's environment.
To begin, set up your project with Vite and Phaser using the official template at saricden's guide. Install Bun by following Bun Docs, and update package.json to use "test": "bun test" for running tests. Ensure test files use extensions like *.test.ts for TypeScript support, which Bun handles natively.
Unit Testing with Bun's Test Framework
Bun's test framework uses a Jest-like API, importing expect and test from "bun:test". It's designed for unit tests, focusing on pure logic not tied to Phaser's rendering. For example, test the GameState class managing resources:
ts
// game-state.test.ts
import { expect, test } from "bun:test";
import GameState from '../utils/game-state';

test('spendResources deducts resources if sufficient', () => {
  const gameState = new GameState();
  gameState.earnResources(100);
  const result = gameState.spendResources(50);
  expect(result).toBe(true);
  expect(gameState.getResources()).toBe(50);
});

test('spendResources fails if insufficient', () => {
  const gameState = new GameState();
  gameState.earnResources(100);
  const result = gameState.spendResources(150);
  expect(result).toBe(false);
  expect(gameState.getResources()).toBe(100);
});
Run tests with bun test, which recursively searches for files like *.test.ts, *_test.ts, *.spec.ts, or *_spec.ts. Bun supports setup/teardown hooks, snapshot testing, and watch mode, enhancing productivity. For code coverage, use bun test --coverage, generating reports in HTML and LCOV formats.
Making Game Logic Testable
Testing game logic, like enemy targeting or tower shooting, can be challenging due to Phaser's browser dependencies. To facilitate testing, extract pure functions. For instance, create a findNearest utility:
ts
// utils.ts
export function findNearest(position: { x: number; y: number }, points: { x: number; y: number }[]): { x: number; y: number } | null {
  if (points.length === 0) return null;
  let nearest = points[0];
  let minDistance = distance(position, nearest);
  for (let i = 1; i < points.length; i++) {
    const dist = distance(position, points[i]);
    if (dist < minDistance) {
      minDistance = dist;
      nearest = points[i];
    }
  }
  return nearest;
}

function distance(p1: { x: number; y: number }, p2: { x: number; y: number }) {
  return Math.hypot(p2.x - p1.x, p2.y - p1.y);
}
Test it with Bun:
ts
// utils.test.ts
import { expect, test } from "bun:test";
import { findNearest } from '../utils';

test('findNearest returns the closest point', () => {
  const position = { x: 0, y: 0 };
  const points = [
    { x: 1, y: 1 },
    { x: 2, y: 2 },
    { x: 0.5, y: 0.5 }
  ];
  const nearest = findNearest(position, points);
  expect(nearest).toStrictEqual({ x: 0.5, y: 0.5 });
});
This approach isolates logic, ensuring testability without browser dependencies. For integration tests requiring Phaser APIs, mock them using Bun's built-in mocking capabilities, though complex interactions may still need Puppeteer.
Functional Testing with Puppeteer and Bun
For tests requiring browser interaction, use Puppeteer, which is compatible with Bun as shown in DEV Community post. Install with:
sh
bun add -D puppeteer
Write a test to start the game and verify the canvas:
ts
// functional.test.ts
import puppeteer from 'puppeteer';

test('Start New Game', async () => {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  await page.goto('http://localhost:3000');
  await page.click('#start-new-game');
  await page.waitForSelector('#game-container canvas');
  const canvas = await page.$('#game-container canvas');
  expect(canvas).not.toBeNull();
  await browser.close();
}, 10000);
Run with bun test functional.test.ts, ensuring your Vite server is running locally. Puppeteer tests can simulate user actions like clicking buttons, placing towers, and checking game states, crucial for verifying main menu navigation, build mode, and combat phases.
Manual Testing
Manual testing validates gameplay experience, focusing on smoothness and responsiveness. Play the game, checking:
Main menu: Start new game, load saved game.
Build mode: Tower placement, resource feedback, ensuring dynamic enemy path recalculation every second, a surprising feature enhancing strategy by adapting to destroyed targets.
Combat phase: Enemy targeting (user if close, then towers, then base), round progression, and "Next Round" button appearance.
User controls: WASD movement, spacebar shooting (range ~200px), healing 20 HP per round.
Performance: Monitor FPS with browser dev tools, ensuring no lag with many entities (e.g., 20 enemies, 10 towers).
Best Practices
Research shows:
Isolate logic for unit testing, using Bun for pure functions.
Automate browser tests with Puppeteer for end-to-end flows, as Bun's test framework lacks browser support.
Manual playtesting is critical for gameplay feel, given interactive nature.
Performance focus: Test with high entity counts, as Phaser games can slow with many sprites.
Implementation Notes
Ensure game code exposes state for testing, e.g., add getCurrentState function:
ts
export function getCurrentState() {
  const gameScene = window.game.scene.keys['GameScene'];
  return {
    enemies: gameScene.enemies?.getChildren().map(enemy => ({ x: enemy.x, y: enemy.y, health: (enemy as any).health })),
    towers: gameScene.towers?.getChildren().map(tower => ({ x: tower.x, y: tower.y })),
    user: { x: gameScene.user.x, y: gameScene.user.y, health: gameScene.user.health },
    base: { health: gameScene.base.health },
    resources: gameScene.gameState.getResources()
  };
}
Use this in Puppeteer tests to verify states, ensuring tests wait for game loop updates.
Conclusion and Next Steps
This guide covers essential testing strategies for tower defense games with Bun, from unit tests to manual playtesting. Developers can extend by adding visual regression testing (e.g., Percy) or load testing for multiplayer features, leveraging Phaser's extensible architecture. For further learning, explore Phaser's official examples for additional inspiration.
Key Citations
Bun test runner documentation
Writing tests with Bun
Running tests with Bun guide
Bun test runner examples
Code coverage with Bun
Using Puppeteer with Bun
Bun v0.6.7 release notes
Try Puppeteer in Bun GitHub repo
Buneteer Puppeteer + Bun starter
saricden's Phaser + Vite guide
Phaser's official examples